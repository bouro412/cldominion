(in-package game)

(defun play-game (plynum)
  (setf *players-list* ())
  (game-init plynum)
  (game-loop plynum))

(defun game-init (plynum)
  (supply-init plynum)
  (players-init plynum)
  (supply-set *basic-cardlist*))

(defun game-loop (plynum)
  (do* ((maxi (1- plynum))
	(turn 0 (if (<= maxi turn)
		    (- turn maxi)
		    (1+ turn)))
	(cp (elt *players-list* 0) (elt *players-list* turn)))
       ((end-gamep) (end-game-process))
    (format t  "プレイヤー~aのターンです。~%" (1+ turn))
    (format t "アクションフェイズに入ります。~%")
    (action-phase cp)
    (format t "アクションフェイズを終わります。~%購入フェイズに入ります。~%")
    (buying-phase cp)
    (format t "購入フェイズを終わります。~%ターンを終了します。~%")
    (turn-end-phase cp)))

(defun action-phase (player)
  (with-accessors ((hc hand-cards) (ac action)) player
    (format t "手札 :~%")
    (print-cards hc)
    (while (and (plusp ac)
		(have-actionp player))
      (if (y-or-n-p "アクションカードを使いますか?")
	  (let ((card-index (choice-card player)))
	    (if (and card-index
		     (card-typep (elt hc card-index) :action))
		(if (progn (print-card (elt hc card-index))
			   (y-or-n-p "このカードを使いますか?"))
		    (use-card player card-index))
		(format t  "アクションカードを選んでください。~%")))
	  (return-from action-phase nil)))))

(defun buying-phase (player)
  (incf (coin player) 
	(reduce #'(lambda (x y) (+ x (card-coin y))) 
		   (hand-cards player)
		   :initial-value 0))
  (shopping player))

(defun turn-end-phase (player)
  (with-accessors ((buy buy) (hc hand-cards) (ac action)
		   (coin coin) (dp discard-pile) (up using-place))
      player
    (setf buy 1 ac 1 coin 0)
    (setf dp (nconc dp hc up))
    (setf hc nil up nil)
    (draw player 5)))

(defun end-game-process ()
  (let ((result nil))
    (dolist (player *players-list*)
      (with-accessors ((deck deck) (hc hand-cards) (dp discard-pile))
	  player
	(setf deck (nconc deck dp hc)
	      hc nil dp nil)
	(let* ((vcard (remove-if-not #'(lambda (x)
					 (or (card-typep x :victory)
					     (card-typep x :curse)))
				     deck))
	       (score (reduce #'(lambda (a b)
				  (+ a b))
			      (mapcar #'(lambda (x) (ability player x))
				      vcard) :initial-value 0)))
	  (push (cons (ID player) score) result))))
    (format t "GameEnd~%Score : ~%")
    (dolist (v (reverse result))
      (format t "  Player~a : ~apoints~%" (car v) (cdr v)))
    (format t "Player ~a is winner!!~%" 
	    (car (rassoc (apply #'max (mapcar #'cdr result))
			 result)))))

(defun players-init (plynum)
  (labels ((make (num)
	     (if (plusp num)
		 (cons (make-player num) (make (1- num)))
		 nil)))
    (setf *players-list* (nreverse (make plynum)))))

(defun make-player (num)
  (let ((p (make-instance 'player :ID num)))
    (dotimes (v 7)
      (take-card-from-supply 'copper p))
    (dotimes (v 3)
      (take-card-from-supply 'estates p))
    (make-deck p)
    (draw p 5)
    p))

(defun use-card (player i)
  (with-accessors ((hc hand-cards) (up using-place) (ac action)) player
    (let ((card (elt hc i)))
      (format t "プレイヤー~aが~aを使いました。~%" (id player) (card-jname card))
      (print-card card)
      (push card up)
      (setf hc (delete card hc :test #'equal :count 1))
      (when (card-typep card :attack)
	(dolist (p (other-players player))
	  (when-bind (rcard (use-reactionp p))
	    (ability p rcard :reac t))))
      (ability player card)
      (decf ac))))

(defun shopping (player)
  (with-accessors ((buy buy) (coin coin)) player
    (while (and (< 0 buy)
		(progn (show-supply)
		       (format t "所持金 : ~a~%" coin) 
		       (y-or-n-p "カードを買いますか?")))
      (buy-card player))))

	  

(defun buy-card (player)
  (let* ((card (choice-supply-card))
	 (card-cost (card-cost card)))
    (if (<= card-cost (coin player))
	(progn 
	  (print-card card)
	  (if (y-or-n-p "このカードを購入しますか?")
	      (progn
		(decf (buy player))
		(decf (coin player) card-cost)
		(take-card-from-supply (card-name card)
				       player))))
	(format t "コインが足りません。~%"))))

(defun use-reactionp (player)
  (when (have-reactionp player)
    (format t "プレイヤー~a リアクションカードがあります。~%" (id player))
    (some #'(lambda (card)
	      (and (card-typep card :reaction)
		   (y-or-n-p 
		    (format nil "リアクションカード ~aを使いますか?~%" 
			    (card-jname card)))
		   card))
	  (hand-cards player))))
  
